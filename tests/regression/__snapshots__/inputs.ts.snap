// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs should properly generate input type class for filtering by enums values: ColorFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { Color } from \\"../../enums/Color\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class ColorFilter {
  @TypeGraphQL.Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  equals?: keyof typeof Color | undefined;

  @TypeGraphQL.Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  not?: keyof typeof Color | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  in?: Array<keyof typeof Color> | undefined;

  @TypeGraphQL.Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  notIn?: Array<keyof typeof Color> | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { BooleanFilter } from \\"../inputs/BooleanFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { JsonFilter } from \\"../inputs/JsonFilter\\";
import { NullableStringFilter } from \\"../inputs/NullableStringFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => NullableStringFilter, {
    nullable: true,
    description: undefined
  })
  optionalStringField?: NullableStringFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  intField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => BooleanFilter, {
    nullable: true,
    description: undefined
  })
  booleanField?: BooleanFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true,
    description: undefined
  })
  dateField?: DateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => JsonFilter, {
    nullable: true,
    description: undefined
  })
  jsonField?: JsonFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: SampleModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: SampleModelWhereInput[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  stringField?: string | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelOrderByInput {
  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  idField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  floatField?: keyof typeof OrderByArg | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelScalarWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelScalarWhereInput[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelWhereInput[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  idField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: string | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: BooleanFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanFilter {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  equals?: boolean | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  not?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: DateTimeFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeFilter {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  equals?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  not?: Date | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  in?: Date[] | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  notIn?: Date[] | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lte?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gte?: Date | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: FloatFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  not?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true,
    description: undefined
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  gte?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class IntFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  not?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true,
    description: undefined
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  gte?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: JsonFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class JsonFilter {
  @TypeGraphQL.Field(_type => GraphQLJSON, {
    nullable: true,
    description: undefined
  })
  equals?: InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLJSON, {
    nullable: true,
    description: undefined
  })
  not?: InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableBooleanFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableBooleanFilter {
  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  equals?: boolean | undefined;

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  not?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableDateTimeFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableDateTimeFilter {
  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  equals?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  not?: Date | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  in?: Date[] | undefined;

  @TypeGraphQL.Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  notIn?: Date[] | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lte?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gt?: Date | undefined;

  @TypeGraphQL.Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gte?: Date | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableFloatFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableFloatFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  not?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true,
    description: undefined
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Float], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Float, {
    nullable: true,
    description: undefined
  })
  gte?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableIntFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableIntFilter {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  equals?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  not?: number | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true,
    description: undefined
  })
  in?: number[] | undefined;

  @TypeGraphQL.Field(_type => [TypeGraphQL.Int], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  lt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  lte?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  gt?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  gte?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableJsonFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableJsonFilter {
  @TypeGraphQL.Field(_type => GraphQLJSON, {
    nullable: true,
    description: undefined
  })
  equals?: InputJsonValue | undefined;

  @TypeGraphQL.Field(_type => GraphQLJSON, {
    nullable: true,
    description: undefined
  })
  not?: InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NullableStringFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class NullableStringFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  not?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  contains?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  endsWith?: string | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringFilter 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class StringFilter {
  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  equals?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  not?: string | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  in?: string[] | undefined;

  @TypeGraphQL.Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  notIn?: string[] | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gt?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gte?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  contains?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  startsWith?: string | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  endsWith?: string | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorOrderByInput {
  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  firstName?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  lastName?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  age?: keyof typeof OrderByArg | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { MovieFilter } from \\"../inputs/MovieFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorWhereInput {
  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  firstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  lastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  age?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => MovieFilter, {
    nullable: true,
    description: undefined
  })
  movies?: MovieFilter | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: DirectorWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: DirectorWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: DirectorWhereInput[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { FirstNameLastNameCompoundUniqueInput } from \\"../inputs/FirstNameLastNameCompoundUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorWhereUniqueInput {
  @TypeGraphQL.Field(_type => FirstNameLastNameCompoundUniqueInput, {
    nullable: true,
    description: undefined
  })
  firstName_lastName?: FirstNameLastNameCompoundUniqueInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: FirstNameLastNameCompoundUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstNameLastNameCompoundUniqueInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined
  })
  firstName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined
  })
  lastName!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined
  })
  directorFirstName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined
  })
  directorLastName!: string;

  @TypeGraphQL.Field(_type => String, {
    nullable: false,
    description: undefined
  })
  title!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieOrderByInput {
  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  directorLastName?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  title?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  rating?: keyof typeof OrderByArg | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieScalarWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieScalarWhereInput {
  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorLastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  title?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  rating?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: MovieScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: MovieScalarWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: MovieScalarWhereInput[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { DirectorWhereInput } from \\"../inputs/DirectorWhereInput\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieWhereInput {
  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorLastName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  title?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  rating?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: MovieWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => DirectorWhereInput, {
    nullable: true,
    description: undefined
  })
  director?: DirectorWhereInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput } from \\"../inputs/DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieWhereUniqueInput {
  @TypeGraphQL.Field(_type => DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, {
    nullable: true,
    description: undefined
  })
  directorFirstName_directorLastName_title?: DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes when model field is renamed: SampleOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleOrderByInput {
  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  idField?: keyof typeof OrderByArg | undefined;

  modelFieldName?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: keyof typeof OrderByArg | undefined) {
    this.modelFieldName = modelFieldName;
  }
}
"
`;

exports[`inputs should properly generate input type classes when model field is renamed: SampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | undefined;

  modelFieldName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: StringFilter | undefined) {
    this.modelFieldName = modelFieldName;
  }
}
"
`;

exports[`inputs should properly generate input type classes when model is renamed: ExampleOrderByInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class ExampleOrderByInput {
  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  intIdField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  stringField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  floatField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  booleanField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  dateField?: keyof typeof OrderByArg | undefined;

  @TypeGraphQL.Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  otherId?: keyof typeof OrderByArg | undefined;
}
"
`;

exports[`inputs should properly generate input type classes when model is renamed: ExampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { BooleanFilter } from \\"../inputs/BooleanFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { OtherModelWhereInput } from \\"../inputs/OtherModelWhereInput\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class ExampleWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  intIdField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  stringField?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | undefined;

  @TypeGraphQL.Field(_type => BooleanFilter, {
    nullable: true,
    description: undefined
  })
  booleanField?: BooleanFilter | undefined;

  @TypeGraphQL.Field(_type => DateTimeFilter, {
    nullable: true,
    description: undefined
  })
  dateField?: DateTimeFilter | undefined;

  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  otherId?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [ExampleWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: ExampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => OtherModelWhereInput, {
    nullable: true,
    description: undefined
  })
  other?: OtherModelWhereInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes when model is renamed: ExampleWhereUniqueInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class ExampleWhereUniqueInput {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true,
    description: undefined
  })
  intIdField?: number | undefined;

  @TypeGraphQL.Field(_type => String, {
    nullable: true,
    description: undefined
  })
  stringField?: string | undefined;
}
"
`;

exports[`inputs when prisma client is generated into node_modules should properly generate prisma client imports in input type class files: SampleWhereInput 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"@prisma/client\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@TypeGraphQL.InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleWhereInput {
  @TypeGraphQL.Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | undefined;

  @TypeGraphQL.Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  modelFieldName?: StringFilter | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: SampleWhereInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: SampleWhereInput[] | undefined;
}
"
`;

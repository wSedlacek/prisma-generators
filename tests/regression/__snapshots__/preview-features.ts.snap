// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`preview features when \`connectOrCreate\` is enabled should properly generate input type classes for connectOrCreate: UserCreateOneWithoutPostsFieldInput 1`] = `
"import { Field, Float, ID, InputType, Int } from \\"@nestjs/graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { UserCreateOrConnectWithoutPostInput } from \\"../inputs/UserCreateOrConnectWithoutPostInput\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class UserCreateOneWithoutPostsFieldInput {
  @ClassTransformer__Type(() => UserCreateWithoutPostsFieldInput)
  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: true,
    description: undefined
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @ClassTransformer__Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
    description: undefined
  })
  connect?: UserWhereUniqueInput | undefined;

  @ClassTransformer__Type(() => UserCreateOrConnectWithoutPostInput)
  @Field(() => UserCreateOrConnectWithoutPostInput, {
    nullable: true,
    description: undefined
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostInput | undefined;
}
"
`;

exports[`preview features when \`connectOrCreate\` is enabled should properly generate input type classes for connectOrCreate: UserCreateOrConnectWithoutPostInput 1`] = `
"import { Field, Float, ID, InputType, Int } from \\"@nestjs/graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class UserCreateOrConnectWithoutPostInput {
  @ClassTransformer__Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, {
    nullable: false,
    description: undefined
  })
  where!: UserWhereUniqueInput;

  @ClassTransformer__Type(() => UserCreateWithoutPostsFieldInput)
  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: false,
    description: undefined
  })
  create!: UserCreateWithoutPostsFieldInput;
}
"
`;

exports[`preview features when \`connectOrCreate\` is enabled should properly generate input type classes for connectOrCreate: UserUpdateOneRequiredWithoutPostsFieldInput 1`] = `
"import { Field, Float, ID, InputType, Int } from \\"@nestjs/graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { JsonValue, InputJsonValue } from \\"../../../../helpers/prisma-client-mock\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { UserCreateOrConnectWithoutPostInput } from \\"../inputs/UserCreateOrConnectWithoutPostInput\\";
import { UserCreateWithoutPostsFieldInput } from \\"../inputs/UserCreateWithoutPostsFieldInput\\";
import { UserUpdateWithoutPostsFieldDataInput } from \\"../inputs/UserUpdateWithoutPostsFieldDataInput\\";
import { UserUpsertWithoutPostsFieldInput } from \\"../inputs/UserUpsertWithoutPostsFieldInput\\";
import { UserWhereUniqueInput } from \\"../inputs/UserWhereUniqueInput\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class UserUpdateOneRequiredWithoutPostsFieldInput {
  @ClassTransformer__Type(() => UserCreateWithoutPostsFieldInput)
  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: true,
    description: undefined
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @ClassTransformer__Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
    description: undefined
  })
  connect?: UserWhereUniqueInput | undefined;

  @ClassTransformer__Type(() => UserUpdateWithoutPostsFieldDataInput)
  @Field(() => UserUpdateWithoutPostsFieldDataInput, {
    nullable: true,
    description: undefined
  })
  update?: UserUpdateWithoutPostsFieldDataInput | undefined;

  @ClassTransformer__Type(() => UserUpsertWithoutPostsFieldInput)
  @Field(() => UserUpsertWithoutPostsFieldInput, {
    nullable: true,
    description: undefined
  })
  upsert?: UserUpsertWithoutPostsFieldInput | undefined;

  @ClassTransformer__Type(() => UserCreateOrConnectWithoutPostInput)
  @Field(() => UserCreateOrConnectWithoutPostInput, {
    nullable: true,
    description: undefined
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostInput | undefined;
}
"
`;

exports[`preview features when \`connectOrCreate\` is enabled should properly generate input type classes for connectOrCreate: inputs index 1`] = `
"export { IntFilter } from \\"./IntFilter\\";
export { PostCreateInput } from \\"./PostCreateInput\\";
export { PostCreateManyWithoutAuthorInput } from \\"./PostCreateManyWithoutAuthorInput\\";
export { PostCreateOrConnectWithoutUserInput } from \\"./PostCreateOrConnectWithoutUserInput\\";
export { PostCreateWithoutAuthorInput } from \\"./PostCreateWithoutAuthorInput\\";
export { PostFilter } from \\"./PostFilter\\";
export { PostOrderByInput } from \\"./PostOrderByInput\\";
export { PostScalarWhereInput } from \\"./PostScalarWhereInput\\";
export { PostUpdateInput } from \\"./PostUpdateInput\\";
export { PostUpdateManyDataInput } from \\"./PostUpdateManyDataInput\\";
export { PostUpdateManyMutationInput } from \\"./PostUpdateManyMutationInput\\";
export { PostUpdateManyWithWhereNestedInput } from \\"./PostUpdateManyWithWhereNestedInput\\";
export { PostUpdateManyWithoutAuthorInput } from \\"./PostUpdateManyWithoutAuthorInput\\";
export { PostUpdateWithWhereUniqueWithoutAuthorInput } from \\"./PostUpdateWithWhereUniqueWithoutAuthorInput\\";
export { PostUpdateWithoutAuthorDataInput } from \\"./PostUpdateWithoutAuthorDataInput\\";
export { PostUpsertWithWhereUniqueWithoutAuthorInput } from \\"./PostUpsertWithWhereUniqueWithoutAuthorInput\\";
export { PostWhereInput } from \\"./PostWhereInput\\";
export { PostWhereUniqueInput } from \\"./PostWhereUniqueInput\\";
export { StringFilter } from \\"./StringFilter\\";
export { UserCreateInput } from \\"./UserCreateInput\\";
export { UserCreateOneWithoutPostsFieldInput } from \\"./UserCreateOneWithoutPostsFieldInput\\";
export { UserCreateOrConnectWithoutPostInput } from \\"./UserCreateOrConnectWithoutPostInput\\";
export { UserCreateWithoutPostsFieldInput } from \\"./UserCreateWithoutPostsFieldInput\\";
export { UserOrderByInput } from \\"./UserOrderByInput\\";
export { UserUpdateInput } from \\"./UserUpdateInput\\";
export { UserUpdateManyMutationInput } from \\"./UserUpdateManyMutationInput\\";
export { UserUpdateOneRequiredWithoutPostsFieldInput } from \\"./UserUpdateOneRequiredWithoutPostsFieldInput\\";
export { UserUpdateWithoutPostsFieldDataInput } from \\"./UserUpdateWithoutPostsFieldDataInput\\";
export { UserUpsertWithoutPostsFieldInput } from \\"./UserUpsertWithoutPostsFieldInput\\";
export { UserWhereInput } from \\"./UserWhereInput\\";
export { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate args classes for model actions resolvers: AggregateUserArgs 1`] = `
"import { ArgsType, Field, Int } from \\"@nestjs/graphql\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { UserDistinctFieldEnum } from \\"../../../../enums/UserDistinctFieldEnum\\";

@ArgsType()
export class AggregateUserArgs {
  @ClassTransformer__Type(() => UserWhereInput)
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;

  @ClassTransformer__Type(() => UserOrderByInput)
  @Field(() => [UserOrderByInput], { nullable: true })
  orderBy?: UserOrderByInput[] | undefined;

  @ClassTransformer__Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, { nullable: true, defaultValue: 20 })
  take?: number | undefined;

  @Field(() => Int, { nullable: true })
  skip?: number | undefined;

  @Field(() => [UserDistinctFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof UserDistinctFieldEnum> | undefined;
}
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate args classes for model actions resolvers: FindManyUserArgs 1`] = `
"import { ArgsType, Field, Int } from \\"@nestjs/graphql\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { UserDistinctFieldEnum } from \\"../../../../enums/UserDistinctFieldEnum\\";

@ArgsType()
export class FindManyUserArgs {
  @ClassTransformer__Type(() => UserWhereInput)
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;

  @ClassTransformer__Type(() => UserOrderByInput)
  @Field(() => [UserOrderByInput], { nullable: true })
  orderBy?: UserOrderByInput[] | undefined;

  @ClassTransformer__Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, { nullable: true, defaultValue: 20 })
  take?: number | undefined;

  @Field(() => Int, { nullable: true })
  skip?: number | undefined;

  @Field(() => [UserDistinctFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof UserDistinctFieldEnum> | undefined;
}
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate model distinct enum when model field is renamed: SampleModelDistinctFieldEnum 1`] = `
"import { registerEnumType } from \\"@nestjs/graphql\\";

export enum SampleModelDistinctFieldEnum {
  intIdField = \\"intIdField\\",
  mappedFieldName = \\"stringField\\",
  intField = \\"intField\\"
}
registerEnumType(SampleModelDistinctFieldEnum, {
  name: \\"SampleModelDistinctFieldEnum\\",
  description: undefined,
});
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate model distinct enum when model is renamed: ExampleModelDistinctFieldEnum 1`] = `
"import { registerEnumType } from \\"@nestjs/graphql\\";

export enum ExampleModelDistinctFieldEnum {
  intIdField = \\"intIdField\\",
  stringField = \\"stringField\\",
  intField = \\"intField\\"
}
registerEnumType(ExampleModelDistinctFieldEnum, {
  name: \\"ExampleModelDistinctFieldEnum\\",
  description: undefined,
});
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate model distinct enum when model is renamed: enums index 1`] = `
"export { ExampleModelDistinctFieldEnum } from \\"./ExampleModelDistinctFieldEnum\\";
export { SortOrder } from \\"./SortOrder\\";
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate model distinct field enum: SampleModelDistinctFieldEnum 1`] = `
"import { registerEnumType } from \\"@nestjs/graphql\\";

export enum SampleModelDistinctFieldEnum {
  intIdField = \\"intIdField\\",
  stringField = \\"stringField\\",
  intField = \\"intField\\"
}
registerEnumType(SampleModelDistinctFieldEnum, {
  name: \\"SampleModelDistinctFieldEnum\\",
  description: undefined,
});
"
`;

exports[`preview features when \`distinct\` is enabled should properly generate model distinct field enum: enums index 1`] = `
"export { SampleModelDistinctFieldEnum } from \\"./SampleModelDistinctFieldEnum\\";
export { SortOrder } from \\"./SortOrder\\";
"
`;

exports[`preview features when both distinct and aggregations features are enabled should properly generate distinct enum arg field and import when model is renamed: AggregateExampleModelArgs 1`] = `
"import { ArgsType, Field, Int } from \\"@nestjs/graphql\\";
import { ExampleModelOrderByInput } from \\"../../../inputs/ExampleModelOrderByInput\\";
import { ExampleModelWhereInput } from \\"../../../inputs/ExampleModelWhereInput\\";
import { ExampleModelWhereUniqueInput } from \\"../../../inputs/ExampleModelWhereUniqueInput\\";
import { Type as ClassTransformer__Type } from \\"class-transformer\\";
import { ExampleModelDistinctFieldEnum } from \\"../../../../enums/ExampleModelDistinctFieldEnum\\";

@ArgsType()
export class AggregateExampleModelArgs {
  @ClassTransformer__Type(() => ExampleModelWhereInput)
  @Field(() => ExampleModelWhereInput, { nullable: true })
  where?: ExampleModelWhereInput | undefined;

  @ClassTransformer__Type(() => ExampleModelOrderByInput)
  @Field(() => [ExampleModelOrderByInput], { nullable: true })
  orderBy?: ExampleModelOrderByInput[] | undefined;

  @ClassTransformer__Type(() => ExampleModelWhereUniqueInput)
  @Field(() => ExampleModelWhereUniqueInput, { nullable: true })
  cursor?: ExampleModelWhereUniqueInput | undefined;

  @Field(() => Int, { nullable: true, defaultValue: 20 })
  take?: number | undefined;

  @Field(() => Int, { nullable: true })
  skip?: number | undefined;

  @Field(() => [ExampleModelDistinctFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof ExampleModelDistinctFieldEnum> | undefined;
}
"
`;
